<html><head><title>Scala Effekt: Multiple Effects</title><meta charset="utf-8" /><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" /><meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="author" content="Jonathan BrachthÃ¤user (@b-studios)" /><meta name="description" content="Extensible algebraic effects with handlers" /><meta name="og:image" content="/scala-effekt/img/poster.png" /><meta name="image" property="og:image" content="/scala-effekt/img/poster.png" /><meta name="og:title" content="Scala Effekt: Multiple Effects" /><meta name="title" property="og:title" content="Scala Effekt: Multiple Effects" /><meta name="og:site_name" content="Scala Effekt" /><meta name="og:url" content="" /><meta name="og:type" content="website" /><meta name="og:description" content="Extensible algebraic effects with handlers" /><link rel="icon" type="image/png" href="/scala-effekt/img/favicon.png" /><meta name="twitter:title" content="Scala Effekt: Multiple Effects" /><meta name="twitter:image" content="/scala-effekt/img/poster.png" /><meta name="twitter:description" content="Extensible algebraic effects with handlers" /><meta name="twitter:card" content="summary_large_image" /><link rel="icon" type="image/png" sizes="16x16" href="/scala-effekt/img/favicon16x16.png" /><link rel="icon" type="image/png" sizes="24x24" href="/scala-effekt/img/favicon24x24.png" /><link rel="icon" type="image/png" sizes="32x32" href="/scala-effekt/img/favicon32x32.png" /><link rel="icon" type="image/png" sizes="48x48" href="/scala-effekt/img/favicon48x48.png" /><link rel="icon" type="image/png" sizes="57x57" href="/scala-effekt/img/favicon57x57.png" /><link rel="icon" type="image/png" sizes="60x60" href="/scala-effekt/img/favicon60x60.png" /><link rel="icon" type="image/png" sizes="64x64" href="/scala-effekt/img/favicon64x64.png" /><link rel="icon" type="image/png" sizes="70x70" href="/scala-effekt/img/favicon70x70.png" /><link rel="icon" type="image/png" sizes="72x72" href="/scala-effekt/img/favicon72x72.png" /><link rel="icon" type="image/png" sizes="76x76" href="/scala-effekt/img/favicon76x76.png" /><link rel="icon" type="image/png" sizes="96x96" href="/scala-effekt/img/favicon96x96.png" /><link rel="icon" type="image/png" sizes="114x114" href="/scala-effekt/img/favicon114x114.png" /><link rel="icon" type="image/png" sizes="120x120" href="/scala-effekt/img/favicon120x120.png" /><link rel="icon" type="image/png" sizes="128x128" href="/scala-effekt/img/favicon128x128.png" /><link rel="icon" type="image/png" sizes="144x144" href="/scala-effekt/img/favicon144x144.png" /><link rel="icon" type="image/png" sizes="150x150" href="/scala-effekt/img/favicon150x150.png" /><link rel="icon" type="image/png" sizes="152x152" href="/scala-effekt/img/favicon152x152.png" /><link rel="icon" type="image/png" sizes="196x196" href="/scala-effekt/img/favicon196x196.png" /><link rel="icon" type="image/png" sizes="310x310" href="/scala-effekt/img/favicon310x310.png" /><link rel="icon" type="image/png" sizes="310x150" href="/scala-effekt/img/favicon310x150.png" /><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" /><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" /><link rel="stylesheet" href="/scala-effekt/highlight/styles/atom-one-light.css" /><link rel="stylesheet" href="/scala-effekt/css/style.css" /><link rel="stylesheet" href="/scala-effekt/css/palette.css" /><link rel="stylesheet" href="/scala-effekt/css/codemirror.css" /><link rel="stylesheet" href="/scala-effekt/css/boilerplate.css" /></head><body class="docs"><div id="wrapper"><div id="sidebar-wrapper"><ul id="sidebar" class="sidebar-nav"><li class="sidebar-brand"><a href="/scala-effekt/" class="brand"><div class="brand-wrapper"><span>Scala Effekt</span></div></a></li> <li><a href="/scala-effekt/guides.html" class="">Guides</a></li> <li><a href="/scala-effekt/guides/getting-started.html" class="">Getting Started</a></li> <li><a href="/scala-effekt/guides/multiple-effects.html" class=" active ">Multiple Effects</a></li> <li><a href="/scala-effekt/guides/multiple-handlers.html" class="">Multiple Handlers at Once</a></li> <li><a href="/scala-effekt/guides/a-normal-form.html" class="">Example: ANF Transformation</a></li> <li><a href="/scala-effekt/guides/piping.html" class="">Example: Piping</a></li></ul></div><div id="page-content-wrapper"><div class="nav"><div class="container-fluid"><div class="row"><div class="col-lg-12"><div class="action-menu pull-left clearfix"><a href="#menu-toggle" id="menu-toggle"><i class="fa fa-bars" aria-hidden="true"></i></a></div><ul class="pull-right"><li id="gh-eyes-item" class="hidden-xs"><a href="https://github.com/b-studios/scala-effekt"><i class="fa fa-eye"></i><span>WATCH<span id="eyes" class="label label-default">--</span></span></a></li><li id="gh-stars-item" class="hidden-xs"><a href="https://github.com/b-studios/scala-effekt"><i class="fa fa-star-o"></i><span>STARS<span id="stars" class="label label-default">--</span></span></a></li><li><a href="#" onclick="shareSiteTwitter('Scala Effekt Extensible algebraic effects with handlers');"><i class="fa fa-twitter"></i></a></li><li><a href="#" onclick="shareSiteFacebook('Scala Effekt Extensible algebraic effects with handlers');"><i class="fa fa-facebook"></i></a></li><li><a href="#" onclick="shareSiteGoogle();"><i class="fa fa-google-plus"></i></a></li></ul></div></div></div></div><div id="content" data-github-owner="b-studios" data-github-repo="scala-effekt"><div class="content-wrapper"><section><h1 id="combining-multiple-effects-with-handlers">Combining Multiple Effects with Handlers</h1>
<p>After having defined a single effect in <a href="./getting-started">Getting Started</a>, this quick tutorial shows how multiple, different effects can be defined and handled in <strong>Effekt</strong>.</p>

<p>Again, we prepared Scasties to follow along with this tutorial.</p>

<ul>
  <li><a href="https://scastie.scala-lang.org/y2xwgsrNT5iKXk0ghfbHJg">Scala 2.12</a> (<a href="https://scastie.scala-lang.org/8z6r2243S02DB50zbetshQ">full solution</a>)</li>
</ul>

<h2 id="defining-a-second-effect">Defining a second effect</h2>
<p>In <a href="./getting-started">Getting Started</a> we have defined ambiguity as our
first effect. The ambiguity effect signature had one effect operation
and looked like this:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">effekt._</span>

<span class="k">trait</span> <span class="nc">Amb</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">flip</span><span class="o">()</span><span class="k">:</span> <span class="kt">Control</span><span class="o">[</span><span class="kt">Boolean</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<div class="language-scala boilerplate highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">ambList</span><span class="o">[</span><span class="kt">R</span><span class="o">](</span><span class="n">prog</span><span class="k">:</span> <span class="kt">Amb</span> <span class="o">=&gt;</span> <span class="nc">Control</span><span class="o">[</span><span class="kt">R</span><span class="o">])</span><span class="k">:</span> <span class="kt">Control</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">R</span><span class="o">]]</span> <span class="k">=</span>
  <span class="k">new</span> <span class="nc">Handler</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">R</span><span class="o">]]</span> <span class="k">with</span> <span class="nc">Amb</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">flip</span><span class="o">()</span> <span class="k">=</span> <span class="n">use</span> <span class="o">{</span> <span class="n">resume</span> <span class="k">=&gt;</span> <span class="k">for</span> <span class="o">{</span>
      <span class="n">ts</span> <span class="k">&lt;-</span> <span class="nf">resume</span><span class="o">(</span><span class="kc">true</span><span class="o">)</span>
      <span class="n">fs</span> <span class="k">&lt;-</span> <span class="nf">resume</span><span class="o">(</span><span class="kc">false</span><span class="o">)</span>
    <span class="o">}</span> <span class="k">yield</span> <span class="n">ts</span> <span class="o">++</span> <span class="n">fs</span> <span class="o">}</span>
  <span class="o">}</span> <span class="n">handle</span> <span class="o">{</span> <span class="n">amb</span> <span class="k">=&gt;</span> <span class="nf">prog</span><span class="o">(</span><span class="n">amb</span><span class="o">)</span> <span class="n">map</span> <span class="o">{</span> <span class="n">r</span> <span class="k">=&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="n">r</span><span class="o">)</span> <span class="o">}</span> <span class="o">}</span>
</code></pre></div></div>
<p>We also defined a handler for the ambiguity effect as an implementation
of the <code class="language-plaintext highlighter-rouge">Amb</code> trait, called <code class="language-plaintext highlighter-rouge">ambList</code>. To see how to combine two
different effects, we will now first define a second (quite standard)
effect: Mutable state. As before we start with the effect signature.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">State</span><span class="o">[</span><span class="kt">S</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">get</span><span class="o">()</span><span class="k">:</span> <span class="kt">Control</span><span class="o">[</span><span class="kt">S</span><span class="o">]</span>
  <span class="k">def</span> <span class="nf">put</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">S</span><span class="o">)</span><span class="k">:</span> <span class="kt">Control</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>
<p>Having defined the effect signature, we can implement a handler that,
like the state monad, does not actually use mutable state but passes
the current value around through the whole program.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">state</span><span class="o">[</span><span class="kt">R</span>, <span class="kt">S</span><span class="o">](</span><span class="n">init</span><span class="k">:</span> <span class="kt">S</span><span class="o">)(</span><span class="n">prog</span><span class="k">:</span> <span class="kt">State</span><span class="o">[</span><span class="kt">S</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nc">Control</span><span class="o">[</span><span class="kt">R</span><span class="o">])</span><span class="k">:</span> <span class="kt">Control</span><span class="o">[</span><span class="kt">R</span><span class="o">]</span> <span class="k">=</span>
  <span class="k">new</span> <span class="nc">Handler</span><span class="o">[</span><span class="kt">S</span> <span class="k">=&gt;</span> <span class="kt">Control</span><span class="o">[</span><span class="kt">R</span><span class="o">]]</span> <span class="k">with</span> <span class="nc">State</span><span class="o">[</span><span class="kt">S</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">put</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">S</span><span class="o">)</span> <span class="k">=</span> <span class="n">use</span> <span class="o">{</span> <span class="n">resume</span> <span class="k">=&gt;</span> <span class="n">pure</span> <span class="o">{</span> <span class="n">s2</span> <span class="k">=&gt;</span> <span class="nf">resume</span><span class="o">(())</span> <span class="n">flatMap</span> <span class="o">{</span> <span class="k">_</span> <span class="n">apply</span> <span class="n">s</span> <span class="o">}</span> <span class="o">}</span> <span class="o">}</span>
    <span class="k">def</span> <span class="nf">get</span><span class="o">()</span>     <span class="k">=</span> <span class="n">use</span> <span class="o">{</span> <span class="n">resume</span> <span class="k">=&gt;</span> <span class="n">pure</span> <span class="o">{</span> <span class="n">s2</span> <span class="k">=&gt;</span> <span class="nf">resume</span><span class="o">(</span><span class="n">s2</span><span class="o">)</span> <span class="n">flatMap</span> <span class="o">{</span> <span class="k">_</span> <span class="n">apply</span> <span class="n">s2</span> <span class="o">}</span> <span class="o">}</span> <span class="o">}</span>
  <span class="o">}</span> <span class="n">handle</span> <span class="o">{</span> <span class="n">state</span> <span class="k">=&gt;</span> <span class="nf">prog</span><span class="o">(</span><span class="n">state</span><span class="o">)</span> <span class="n">map</span> <span class="o">{</span> <span class="n">r</span> <span class="k">=&gt;</span> <span class="n">s</span> <span class="k">=&gt;</span> <span class="nf">pure</span><span class="o">(</span><span class="n">r</span><span class="o">)</span> <span class="o">}</span> <span class="o">}</span> <span class="n">flatMap</span> <span class="o">{</span> <span class="k">_</span> <span class="n">apply</span> <span class="n">init</span> <span class="o">}</span>
</code></pre></div></div>

<h2 id="using-amb-and-state-in-one-example">Using <code class="language-plaintext highlighter-rouge">Amb</code> and <code class="language-plaintext highlighter-rouge">State</code> in one example</h2>
<p>Let us now use the two effects to write a program that combines them.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">def</span> <span class="nf">example</span><span class="o">(</span><span class="k">implicit</span> <span class="n">s</span><span class="k">:</span> <span class="kt">State</span><span class="o">[</span><span class="kt">Int</span><span class="o">],</span> <span class="n">amb</span><span class="k">:</span> <span class="kt">Amb</span><span class="o">)</span><span class="k">:</span> <span class="kt">Control</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="k">for</span> <span class="o">{</span>
  <span class="n">x</span> <span class="k">&lt;-</span> <span class="nv">s</span><span class="o">.</span><span class="py">get</span><span class="o">()</span>
  <span class="n">b</span> <span class="k">&lt;-</span> <span class="nv">amb</span><span class="o">.</span><span class="py">flip</span><span class="o">()</span>
  <span class="k">_</span> <span class="k">&lt;-</span> <span class="nf">if</span> <span class="o">(</span><span class="n">b</span><span class="o">)</span> <span class="nv">s</span><span class="o">.</span><span class="py">put</span><span class="o">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="k">else</span> <span class="nf">pure</span><span class="o">(())</span>
  <span class="n">y</span> <span class="k">&lt;-</span> <span class="nv">s</span><span class="o">.</span><span class="py">get</span><span class="o">()</span>
<span class="o">}</span> <span class="nf">yield</span> <span class="o">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="o">)</span>
</code></pre></div></div>
<p>The example program requires capabilities for both effects, a state
effect carrying an integer and the ambiguity effect. We first retreive
the current state, then toss a coin and depending on result mutate the
state (or not).</p>

<p>As you can see, there is nothing special to using more than one effect.
The use of effects naturally composes.</p>

<h2 id="handling-the-two-effects">Handling the two effects</h2>
<p>As with monad transformers, we have two different ways of handling the
two effects. Should we first handle away the ambiguity effect and then
consider state, or the other way around? The nice thing with algebraic
effects and handlers is that we can decide very late.</p>

<p>Letâs experiment with the two options:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">result1</span><span class="k">:</span> <span class="kt">Control</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="n">ambList</span> <span class="o">{</span> <span class="k">implicit</span> <span class="n">a</span><span class="k">:</span> <span class="kt">Amb</span> <span class="o">=&gt;</span>
  <span class="nf">state</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="o">{</span> <span class="k">implicit</span> <span class="n">s</span><span class="k">:</span> <span class="kt">State</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=&gt;</span>
    <span class="n">example</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="nv">result1</span><span class="o">.</span><span class="py">run</span><span class="o">()</span>
<span class="n">res0</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span>
</code></pre></div></div>

<p>In this variant, we first handle away the state effect and then handle ambiguity.
The ambiguity handler invokes the continuation twice, once with <code class="language-plaintext highlighter-rouge">true</code>
and once with <code class="language-plaintext highlighter-rouge">false</code>. Since the state handler is nested in the
ambiguity handler, it will be reset for the second invocation with <code class="language-plaintext highlighter-rouge">false</code>
and thus the second element in the resulting list is <code class="language-plaintext highlighter-rouge">0</code>.</p>

<p>Commuting the two handlers, we get different results:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">result2</span> <span class="k">=</span> <span class="nf">state</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="o">{</span> <span class="k">implicit</span> <span class="n">s</span><span class="k">:</span> <span class="kt">State</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=&gt;</span>
  <span class="n">ambList</span> <span class="o">{</span> <span class="k">implicit</span> <span class="n">a</span><span class="k">:</span> <span class="kt">Amb</span> <span class="o">=&gt;</span>
    <span class="n">example</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="nv">result2</span><span class="o">.</span><span class="py">run</span><span class="o">()</span>
<span class="n">res1</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span>
</code></pre></div></div>

<p>Now, ambiguity is run inside of state and the change of state carries
over to the second coin flipping result.</p>
</section></div></div></div></div><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/js/bootstrap.min.js"></script><script src="/scala-effekt/highlight/highlight.pack.js"></script><script>hljs.configure({languages:['scala','java','bash']});
hljs.initHighlighting();
              </script><script src="/scala-effekt/js/boilerplate.js"></script><script>((window.gitter = {}).chat = {}).options = {
room: 'b-studios/scala-effekt'};</script><script src="https://sidecar.gitter.im/dist/sidecar.v1.js"></script><script src="/scala-effekt/js/main.js"></script></body></html>